package com.nist.ccmserver;
/* Generated By:JavaCC: Do not edit this line. ConstraintParser.java */
import java.util.HashMap;
import java.util.ArrayList;
import java.io.StringReader;

public class ConstraintParser implements ConstraintParserConstants {

   // store parameter values
   private HashMap params;

   // a list of parameters that appear in the constraint
   private ArrayList<Parameter> usedParams;

   public ConstraintParser (String constraint) {
      this(new StringReader (constraint));
      params = new HashMap ();
      usedParams = new ArrayList<Parameter> ();
   }

   public ConstraintParser (String constraint,HashMap paramsMap) {
      this(new StringReader (constraint));
      params = paramsMap;
      usedParams = new ArrayList<Parameter> ();
   }

   // add a param/value pair
   public void addParam (String pname, Object pvalue) {
      params.put(pname, pvalue);
   }

        // get the list of used parameters
        public ArrayList<Parameter> getUsedParamList () {
                return usedParams;
        }

   public Object lookup (String pname) {
     return params.get(pname);
   }

   public void parse () throws ParseException {
        Constraint (true);
   }

   public boolean evaluate () {
      boolean rval = true;
      try {
        rval = ((Boolean) Constraint (false)).booleanValue();
      }
      catch (Exception ex) {
        System.out.println("Parser Exception: " + ex);
        rval = false;
      }

      return rval;
   }

   public static void main (String args[]) {
      ConstraintParser parser = new ConstraintParser (args[0]);
      //parser.addParam ("x", Boolean.TRUE);
      //parser.addParam ("y", new Integer(10));
      //parser.addParam ("z", "test");
      //System.out.println(parser.evaluate());
      //System.out.println(parser.parse());
   }

  final public Object Constraint(boolean parse_only) throws ParseException {
   Object rval;
    rval = LogicalExpression(parse_only);
     if (parse_only) {
        TypeInfo rvalTI = (TypeInfo) rval;
        if (rvalTI.getType() != Constants.TYPE_BOOL) {
           {if (true) throw new ParseException("Boolean expression expected:\u005cn" + rvalTI.getText());}
        }
     }
     {if (true) return rval;}
    throw new Error("Missing return statement in function");
  }

  final public Object LogicalExpression(boolean parse_only) throws ParseException {
   Object rval;
    rval = ImplicativeExpression(parse_only);
         {if (true) return rval;}
    throw new Error("Missing return statement in function");
  }

  final public Object ImplicativeExpression(boolean parse_only) throws ParseException {
   Token t = null;
   Object rval;
   Object temp;
   TypeInfo rvalTI = new TypeInfo();
   TypeInfo tempTI = new TypeInfo();
    rval = OrExpression(parse_only);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IM:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      t = jj_consume_token(IM);
      temp = OrExpression(parse_only);
                if(parse_only){
            tempTI  = (TypeInfo)temp;
            rvalTI = (TypeInfo)rval;

            TypeInfo rv = new TypeInfo();
            rv.setType(Constants.TYPE_BOOL);
            rv.setText(rvalTI.getText() + " " + t.image + " " + tempTI.getText());

            if(rvalTI.getType() != Constants.TYPE_BOOL) {
               {if (true) throw new ParseException("Boolean type expected: " + rvalTI.getText()
                                        + "\u005cn" + "   in expression: " + rv.getText());}
            }
            else if(tempTI.getType() != Constants.TYPE_BOOL) {
               {if (true) throw new ParseException("Boolean type expected: " + tempTI.getText()
                                        + "\u005cn" + "   in expression: " + rv.getText());}
            }
            rval = rv;
      } else {
        rval = new Boolean (
                  !((Boolean) rval).booleanValue ()
                   || ((Boolean) temp).booleanValue ());
      }
    }
     {if (true) return rval;}
    throw new Error("Missing return statement in function");
  }

  final public Object OrExpression(boolean parse_only) throws ParseException {
   Token t = null;
   Object rval;
   Object temp;
   TypeInfo rvalTI = new TypeInfo();
   TypeInfo tempTI = new TypeInfo();
    rval = AndExpression(parse_only);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      t = jj_consume_token(OR);
      temp = AndExpression(parse_only);
        if(parse_only){
            tempTI  = (TypeInfo)temp;
            rvalTI = (TypeInfo)rval;

            TypeInfo rv = new TypeInfo();
            rv.setType(Constants.TYPE_BOOL);
            rv.setText(rvalTI.getText() + " " + t.image + " " + tempTI.getText());
            if(rvalTI.getType() != Constants.TYPE_BOOL) {
               {if (true) throw new ParseException("Boolean type expected: " + rvalTI.getText()
                                        + "\u005cn" + "   in expression: " + rv.getText());}
            }
            else if(tempTI.getType() != Constants.TYPE_BOOL) {
                {if (true) throw new ParseException("Boolean type expected: " + tempTI.getText()
                                         + "\u005cn" + "   in expression: " + rv.getText());}
            }
            rval = rv;
            } else {
           rval = new Boolean (
               ((Boolean) rval).booleanValue()
               || ((Boolean) temp).booleanValue());
        }
    }
      {if (true) return rval;}
    throw new Error("Missing return statement in function");
  }

  final public Object AndExpression(boolean parse_only) throws ParseException {
   Token t = null;
   Object rval;
   Object temp;
   TypeInfo rvalTI = null;
   TypeInfo tempTI = null;
    rval = RelationalExpression(parse_only);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_3;
      }
      t = jj_consume_token(AND);
      temp = RelationalExpression(parse_only);
        if(parse_only){
            tempTI  = (TypeInfo)temp;
            rvalTI = (TypeInfo)rval;

            TypeInfo rv = new TypeInfo();
            rv.setType(Constants.TYPE_BOOL);
            rv.setText(rvalTI.getText() + " " + t.image + " " + tempTI.getText());

            if(rvalTI.getType() != Constants.TYPE_BOOL) {
               {if (true) throw new ParseException("Boolean type expected: " + rvalTI.getText()
                                        + "\u005cn" + "   in expression: " + rv.getText());}
            }
            else if(tempTI.getType() != Constants.TYPE_BOOL) {
                {if (true) throw new ParseException("Boolean type expected: " + tempTI.getText()
                                         + "\u005cn" + "   in expression: " + rv.getText());}
            }
            rval = rv;
             } else {
             rval = new Boolean(
                   ((Boolean) rval).booleanValue ()
                   && ((Boolean) temp).booleanValue ());
         }
    }
       {if (true) return rval;}
    throw new Error("Missing return statement in function");
  }

  final public Object RelationalExpression(boolean parse_only) throws ParseException {
   Token t = null;
   Object rval;
   Object temp;
   TypeInfo rvalTI = null;
   TypeInfo tempTI = null;
    rval = AdditiveExpression(parse_only);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
      case GT:
      case LT:
      case LE:
      case GE:
      case NE:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_4;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        t = jj_consume_token(LT);
        temp = AdditiveExpression(parse_only);
            if(parse_only){
            tempTI  = (TypeInfo)temp;
            rvalTI = (TypeInfo)rval;

            TypeInfo rv = new TypeInfo();
            rv.setType(Constants.TYPE_BOOL);
            rv.setText(rvalTI.getText() + " " + t.image + " " + tempTI.getText());

            if(rvalTI.getType() != Constants.TYPE_INT
               && rvalTI.getType () != Constants.TYPE_STRING) {
               {if (true) throw new ParseException("Integer or String type expected: " + rvalTI.getText()
                                        + "\u005cn" + "   in expression: " + rv.getText());}
            }
            else if(tempTI.getType() != Constants.TYPE_INT
                    && tempTI.getType() != Constants.TYPE_STRING) {
                {if (true) throw new ParseException("Integer or String type expected: " + tempTI.getText()
                                         + "\u005cn" + "   in expression: " + rv.getText());}
            }
            else if (tempTI.getType () != rvalTI.getType ()) {
                {if (true) throw new ParseException("Type mismatch: " + rvalTI.getText()
                                           + " " + t.image + " " + tempTI.getText());}
            }
            rval = rv;
        } else {
          if (temp instanceof Integer) {
            if(((Integer) rval).intValue() < ((Integer) temp).intValue ()) {
               rval = Boolean.TRUE;
            }
            else {
               rval = Boolean.FALSE;
            }
          }
          else if (temp instanceof String) {
            int tmp = ((String) rval).compareTo ((String) temp);
            if (tmp < 0) {
               rval = Boolean.TRUE;
            }
            else {
               rval = Boolean.FALSE;
            }
          }
        }
        break;
      case GT:
        t = jj_consume_token(GT);
        temp = AdditiveExpression(parse_only);
        if(parse_only){
            tempTI  = (TypeInfo)temp;
            rvalTI = (TypeInfo)rval;

            TypeInfo rv = new TypeInfo();
            rv.setType(Constants.TYPE_BOOL);
            rv.setText(rvalTI.getText() + " " + t.image + " " + tempTI.getText());

            if(rvalTI.getType() != Constants.TYPE_INT
               && rvalTI.getType () != Constants.TYPE_STRING) {
               {if (true) throw new ParseException("Integer or String type expected: " + rvalTI.getText()
                                        + "\u005cn" + "   in expression: " + rv.getText());}
            }
            else if(tempTI.getType() != Constants.TYPE_INT
                    && tempTI.getType() != Constants.TYPE_STRING) {
                {if (true) throw new ParseException("Integer or String type expected: " + tempTI.getText()
                                         + "\u005cn" + "   in expression: " + rv.getText());}
            }
            else if (tempTI.getType () != rvalTI.getType ()) {
                {if (true) throw new ParseException("Type mismatch: " + rvalTI.getText()
                                           + " " + t.image + " " + tempTI.getText());}
            }
            rval = rv;
         } else {
           if (temp instanceof Integer) {
             if(((Integer) rval).intValue() > ((Integer) temp).intValue()) {
               rval = Boolean.TRUE;
             } else {
               rval = Boolean.FALSE;
             }
           }
           else if (temp instanceof String) {
             int tmp = ((String) rval).compareTo ((String) temp);
             if (tmp > 0) {
               rval = Boolean.TRUE;
             }
             else {
               rval = Boolean.FALSE;
             }
           }
        }
        break;
      case LE:
        t = jj_consume_token(LE);
        temp = AdditiveExpression(parse_only);
        if(parse_only){
            tempTI  = (TypeInfo)temp;
            rvalTI = (TypeInfo)rval;

            TypeInfo rv = new TypeInfo();
            rv.setType(Constants.TYPE_BOOL);
            rv.setText(rvalTI.getText() + " " + t.image + " " + tempTI.getText());

            if(rvalTI.getType() != Constants.TYPE_INT
               && rvalTI.getType () != Constants.TYPE_STRING) {
               {if (true) throw new ParseException("Integer or String type expected: " + rvalTI.getText()
                                        + "\u005cn" + "   in expression: " + rv.getText());}
            }
            else if(tempTI.getType() != Constants.TYPE_INT
                    && tempTI.getType() != Constants.TYPE_STRING) {
                {if (true) throw new ParseException("Integer or String type expected: " + tempTI.getText()
                                         + "\u005cn" + "   in expression: " + rv.getText());}
            }
            else if (tempTI.getType () != rvalTI.getType ()) {
                {if (true) throw new ParseException("Type mismatch: " + rvalTI.getText()
                                           + " " + t.image + " " + tempTI.getText());}
            }
            rval = rv;
        } else {
          if (temp instanceof Integer) {
            if(((Integer) rval).intValue() <= ((Integer) temp).intValue()) {
               rval = Boolean.TRUE;
            }
            else {
               rval = Boolean.FALSE;
            }
          }
          else if (temp instanceof String) {
            int tmp = ((String) rval).compareTo ((String) temp);
            if (tmp <= 0) {
               rval = Boolean.TRUE;
            }
            else {
               rval = Boolean.FALSE;
            }
          }
       }
        break;
      case GE:
        t = jj_consume_token(GE);
        temp = AdditiveExpression(parse_only);
        if(parse_only){
            tempTI  = (TypeInfo)temp;
            rvalTI = (TypeInfo)rval;

            TypeInfo rv = new TypeInfo();
            rv.setType(Constants.TYPE_BOOL);
            rv.setText(rvalTI.getText() + " " + t.image + " " + tempTI.getText());

            if(rvalTI.getType() != Constants.TYPE_INT
               && rvalTI.getType () != Constants.TYPE_STRING) {
               {if (true) throw new ParseException("Integer or String type expected: " + rvalTI.getText()
                                        + "\u005cn" + "   in expression: " + rv.getText());}
            }
            else if(tempTI.getType() != Constants.TYPE_INT
                    && tempTI.getType() != Constants.TYPE_STRING) {
                {if (true) throw new ParseException("Integer or String type expected: " + tempTI.getText()
                                         + "\u005cn" + "   in expression: " + rv.getText());}
            }
            else if (tempTI.getType () != rvalTI.getType ()) {
                {if (true) throw new ParseException("Type mismatch: " + rvalTI.getText()
                                           + " " + t.image + " " + tempTI.getText());}
            }
            rval = rv;
        } else {
           if (temp instanceof Integer) {
             if(((Integer) rval).intValue() >= ((Integer) temp).intValue()) {
               rval = Boolean.TRUE;
             }
             else {
               rval = Boolean.FALSE;
             }
           }
           else if (temp instanceof String) {
             int tmp = ((String) rval).compareTo ((String) temp);
             if (tmp >= 0) {
               rval = Boolean.TRUE;
             }
             else {
               rval = Boolean.FALSE;
             }
           }
        }
        break;
      case EQ:
        t = jj_consume_token(EQ);
        temp = AdditiveExpression(parse_only);
       if(parse_only){
            tempTI  = (TypeInfo)temp;
            rvalTI = (TypeInfo)rval;

            if(rvalTI.getType() != tempTI.getType()) {
                    {if (true) throw new ParseException ("Type mismatch: " + tempTI.getType()
                        + rvalTI.getText() + " " + t.image + " " + tempTI.getText());}
            } else  {
                TypeInfo ti = new TypeInfo();
                ti.setType(Constants.TYPE_BOOL);
                ti.setText(rvalTI.getText() + " " + t.image + " " + tempTI.getText());
                rval = ti;;
           }
        } else {
          if (temp instanceof Integer) {
             if(((Integer) rval).intValue() == ((Integer) temp).intValue()) {
                rval = Boolean.TRUE;
             }
             else {
               rval = Boolean.FALSE;
             }
          }
          else if (temp instanceof String) {
             int tmp = ((String) rval).compareTo ((String) temp);
             if (tmp == 0) {
               rval = Boolean.TRUE;
             }
             else {
               rval = Boolean.FALSE;
             }
          }
          else if (temp instanceof Boolean) {
             if(((Boolean) rval).equals(temp)) {
               rval = Boolean.TRUE;
             }
             else {
               rval = Boolean.FALSE;
             }
          }
       }
        break;
      case NE:
        t = jj_consume_token(NE);
        temp = AdditiveExpression(parse_only);
       if(parse_only){
            tempTI  = (TypeInfo)temp;
            rvalTI = (TypeInfo)rval;

            TypeInfo ti = new TypeInfo();
            ti.setType(Constants.TYPE_BOOL);
            ti.setText(rvalTI.getText() + " " + t.image + " " + tempTI.getText());

            if(rvalTI.getType() != tempTI.getType()) {
                    {if (true) throw new ParseException ("Type mismatch: "
                        + rvalTI.getText() + " " + t.image + " " + tempTI.getText());}
            }
            rval = ti;;
        } else {
            if (temp instanceof Integer) {
              if(((Integer) rval).intValue() != ((Integer) temp).intValue()) {
                rval = Boolean.TRUE;
              }
              else {
                rval = Boolean.FALSE;
              }
            }
            else if (temp instanceof String) {
              int tmp = ((String) rval).compareTo ((String) temp);
              if (tmp != 0) {
                rval = Boolean.TRUE;
              }
              else {
                rval = Boolean.FALSE;
              }
            }
            else if (temp instanceof Boolean) {
              if(!((Boolean) rval).equals(temp)) {
                rval = Boolean.TRUE;
              }
              else {
                rval = Boolean.FALSE;
              }
            }
       }
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return rval;}
    throw new Error("Missing return statement in function");
  }

  final public Object AdditiveExpression(boolean parse_only) throws ParseException {
   Token t = null;
   Object rval = null;
   Object temp;
   TypeInfo rvalTI = null;
   TypeInfo tempTI = null;
    rval = MultiplicativeExpression(parse_only);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        temp = MultiplicativeExpression(parse_only);
        if(parse_only){
            tempTI  = (TypeInfo)temp;
            rvalTI = (TypeInfo)rval;

            TypeInfo rv = new TypeInfo();
            rv.setType(Constants.TYPE_INT);
            rv.setText(rvalTI.getText() + " " + t.image + " " + tempTI.getText());

            if(rvalTI.getType() != Constants.TYPE_INT) {
               {if (true) throw new ParseException("Integer type expected: " + rvalTI.getText()
                                        + "\u005cn" + "   in expression: " + rv.getText());}
            }
            else if(tempTI.getType() != Constants.TYPE_INT) {
                {if (true) throw new ParseException("Integer type expected: " + tempTI.getText()
                                         + "\u005cn" + "   in expression: " + rv.getText());}
            }
            rval = rv;
        } else {
            rval = new Integer(((Integer) rval).intValue() + ((Integer) temp).intValue ());
        }
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        temp = MultiplicativeExpression(parse_only);
        if(parse_only){
            tempTI  = (TypeInfo)temp;
            rvalTI = (TypeInfo)rval;

            TypeInfo rv = new TypeInfo();
            rv.setType(Constants.TYPE_INT);
            rv.setText(rvalTI.getText() + " " + t.image + " " + tempTI.getText());

            if(rvalTI.getType() != Constants.TYPE_INT) {
               {if (true) throw new ParseException("Integer type expected: " + rvalTI.getText()
                                        + "\u005cn" + "   in expression: " + rv.getText());}
            }
            else if(tempTI.getType() != Constants.TYPE_INT) {
                {if (true) throw new ParseException("Integer type expected: " + tempTI.getText()
                                         + "\u005cn" + "   in expression: " + rv.getText());}
            }
            rval = rv;
         } else {
            rval = new Integer(((Integer) rval).intValue() - ((Integer) temp).intValue ());
         }
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return rval;}
    throw new Error("Missing return statement in function");
  }

  final public Object MultiplicativeExpression(boolean parse_only) throws ParseException {
   Token t = null;
   Object rval = null;
   Object temp;
   TypeInfo rvalTI = null;
   TypeInfo tempTI = null;
    rval = UnaryExpression(parse_only);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MUL:
      case DIV:
      case MOD:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_6;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MUL:
        t = jj_consume_token(MUL);
        temp = UnaryExpression(parse_only);
        if(parse_only){
            tempTI  = (TypeInfo)temp;
            rvalTI = (TypeInfo)rval;

            TypeInfo rv = new TypeInfo();
            rv.setType(Constants.TYPE_INT);
            rv.setText(rvalTI.getText() + " " + t.image + " " + tempTI.getText());

            if(rvalTI.getType() != Constants.TYPE_INT) {
               {if (true) throw new ParseException("Integer type expected: " + rvalTI.getText()
                                        + "\u005cn" + "   in expression: " + rv.getText());}
            }
            else if(tempTI.getType() != Constants.TYPE_INT) {
                {if (true) throw new ParseException("Integer type expected: " + tempTI.getText()
                                         + "\u005cn" + "   in expression: " + rv.getText());}
            }
            rval = rv;
            } else {
                rval = new Integer(((Integer) rval).intValue() * ((Integer) temp).intValue ());
        }
        break;
      case DIV:
        t = jj_consume_token(DIV);
        temp = UnaryExpression(parse_only);
        if(parse_only){
            tempTI  = (TypeInfo)temp;
            rvalTI = (TypeInfo)rval;

            TypeInfo rv = new TypeInfo();
            rv.setType(Constants.TYPE_INT);
            rv.setText(rvalTI.getText() + " " + t.image + " " + tempTI.getText());

            if(rvalTI.getType() != Constants.TYPE_INT) {
               {if (true) throw new ParseException("Integer type expected: " + rvalTI.getText()
                                        + "\u005cn" + "   in expression: " + rv.getText());}
            }
            else if(tempTI.getType() != Constants.TYPE_INT) {
               {if (true) throw new ParseException("Integer type expected: " + tempTI.getText()
                                                                + "\u005cn" + "   in expression: " + rv.getText());}
            }
            rval = rv;
            } else {
            rval = new Integer(((Integer) rval).intValue() / ((Integer) temp).intValue ());
        }
        break;
      case MOD:
        t = jj_consume_token(MOD);
        temp = UnaryExpression(parse_only);
         if(parse_only){
            tempTI  = (TypeInfo)temp;
            rvalTI = (TypeInfo)rval;

            TypeInfo rv = new TypeInfo();
            rv.setType(Constants.TYPE_INT);
            rv.setText(rvalTI.getText() + " " + t.image + " " + tempTI.getText());

            if(rvalTI.getType() != Constants.TYPE_INT) {
               {if (true) throw new ParseException("Integer type expected: " + rvalTI.getText()
                                                                 + "\u005cn" + "  in expression: " + rv.getText());}

            }
            else if(tempTI.getType() != Constants.TYPE_INT) {
               {if (true) throw new ParseException("Integer type expected: " + tempTI.getText()
                                         + "\u005cn" + "   in expression: " + rv.getText());}
            }
            rval = rv;
          } else {
            rval = new Integer(((Integer) rval).intValue() % ((Integer) temp).intValue ());
         }
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     {if (true) return rval;}
    throw new Error("Missing return statement in function");
  }

  final public Object UnaryExpression(boolean parse_only) throws ParseException {
   Token t = null;
   Token tt = null;
   Object temp;
   Object rval = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      t = jj_consume_token(INTEGER_LITERAL);
      if(parse_only) {
        TypeInfo rv = new TypeInfo();
        rv.setType(Constants.TYPE_INT);
        rv.setText(t.image);
        rval = rv;
      } else {
        int val = Integer.parseInt (t.image);
        rval = new Integer (val);
      }
      break;
    case STRING_LITERAL:
      t = jj_consume_token(STRING_LITERAL);
       if(parse_only) {
              TypeInfo rv = new TypeInfo();
              rv.setType(Constants.TYPE_STRING);
              rv.setText(t.image);
              rval = rv;
                } else {
          // strip the quotes
          rval = t.image.substring(1, t.image.length()-1).trim();
       }
      break;
    case TRUE:
      t = jj_consume_token(TRUE);
      if(parse_only){
         TypeInfo rv = new TypeInfo();
         rv.setType(Constants.TYPE_BOOL);
         rv.setText(t.image);
         rval = rv;
      } else {
         rval = Boolean.TRUE;
      }
      break;
    case FALSE:
      t = jj_consume_token(FALSE);
      if(parse_only){
         TypeInfo rv = new TypeInfo();
         rv.setType(Constants.TYPE_BOOL);
         rv.setText(t.image);
         rval = rv;
      } else {
         rval = Boolean.FALSE;
      }
      break;
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
      if(parse_only){
             Parameter param = (Parameter) lookup(t.image);
             if (param == null) {
                {if (true) throw new ParseException("Unrecognized parameter: " + t.image
                                                                        + "\u005cnIf this is a param value (i.e., not a param name), it needs to be quoted.");}
             } else {
                // TODO:Enum needs to be converted to string.  
                TypeInfo rv = new TypeInfo();
                rv.setType (param.getType());
                rv.setText (t.image);
                rval = rv;

                // add this valid parameter into usedParam list
                usedParams.add (param);
             }
          } else {
            // look up the value of a variable
            rval = lookup (t.image);
                if (rval == null) {
                   {if (true) throw new ParseException ("Unrecognized parameter: " + t.image
                                                                                + "\u005cnIf this is a param value (i.e., not a param name), it needs to be quoted.");}
            }
          }
      break;
    case NOT:
      t = jj_consume_token(NOT);
      temp = UnaryExpression(parse_only);
        if(parse_only) {
          TypeInfo ti = (TypeInfo) temp;
          if (ti.getType() != Constants.TYPE_BOOL) {
                {if (true) throw new ParseException ("Boolean type expected: " + ti.getText()
                                          + "\u005cn" + "   in expression: " + t.image + " " + ti.getText());}
          }
          TypeInfo rv = new TypeInfo();
          rv.setType(Constants.TYPE_BOOL);
          rv.setText(t.image + " " + ti.getText());
          rval = rv;
        } else {
              rval = new Boolean(
                       !((Boolean) temp).booleanValue ()
                     );
            }
      break;
   
    	
    case OPENPAR:
      t = jj_consume_token(OPENPAR);
      rval = LogicalExpression(parse_only);
      tt = jj_consume_token(CLOSEPAR);
       if(parse_only) {
         TypeInfo rvalTI = (TypeInfo) rval;
         TypeInfo ti = new TypeInfo ();
         ti.setType (rvalTI.getType());
         ti.setText (t.image + rvalTI.getText() + tt.image);
         rval = ti;
       }
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
       {if (true) return rval;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public ConstraintParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[10];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x200000,0x80000,0x40000,0x3f000,0x3f000,0xc00000,0xc00000,0x7000000,0x7000000,0x81003e0,};
   }

  /** Constructor with InputStream. */
  public ConstraintParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public ConstraintParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ConstraintParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public ConstraintParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ConstraintParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public ConstraintParser(ConstraintParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(ConstraintParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[29];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 10; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 29; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
